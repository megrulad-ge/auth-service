import { Test, TestingModule } from '@nestjs/testing';
import { SessionController } from './session.controller';
import { SessionService } from './session.service';
import { SetupModule } from '/common/setup/setup.module';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Session } from '/src/session/entities/session.entity';
import { AuthModule } from '/src/auth/auth.module';
import { UserClaims } from '/src/users/user.type';
import { User } from '/src/users/entities/user.entity';
import { DataSource, Repository } from 'typeorm';

describe('SessionController', () => {
  let controller: SessionController;
  let connection: DataSource;
  let sessionService: SessionService;
  let usersRepository: Repository<User>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: [SetupModule, AuthModule, TypeOrmModule.forFeature([Session, User])],
      controllers: [SessionController],
      providers: [SessionService],
    }).compile();

    await module.init();

    connection = module.get(DataSource);
    controller = module.get(SessionController);
    sessionService = module.get(SessionService);
    usersRepository = connection.getRepository(User);
  });

  describe('refresh', () => {
    it('should refresh token by injecting decoded claims and create a new one', async () => {
      // Arrange
      const date = new Date('1970-01-19T10:12:37.600Z');
      const decodedClaims: UserClaims = {
        uuid: 'affa8b1c-4c7a-4b9a-9b0a-0e9b6e1a0b1c',
        roles: ['admin', 'user', 'guest'],
        iat: date.getTime(),
        exp: date.getTime() + 1000,
      };

      // Act
      const result = controller.refresh(decodedClaims);

      // Assert
      expect(result).toBeDefined();
      expect(result).toEqual(
        expect.objectContaining({
          accessToken: expect.any(String),
          expiresIn: 600, // 10 minutes in seconds, set via environment variable
        }),
      );
    });
  });

  describe('extend', () => {
    it('should extend the session by using the refresh-token/session-key and create a new token', async () => {
      // Arrange
      const username = 'username-123';
      const password = 'password-123';
      const createdUser = await usersRepository.save({
        username,
        password,
      });
      const createdSession = await sessionService.save('session', 'userAgent', new Date(), createdUser);
      const refreshToken = createdSession.session; // UUID generated by TypeORM

      // Act
      const result = await controller.extend({ refreshToken });

      // Assert
      expect(result).toBeDefined();
      expect(result).toEqual(
        expect.objectContaining({
          accessToken: expect.any(String),
          expiresIn: 600,
        }),
      );
    });
  });
});
